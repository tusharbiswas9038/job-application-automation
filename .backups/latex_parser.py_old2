# resume/latex_parser.py
import re
import logging
from pathlib import Path
from typing import Optional, Dict, List, Tuple
from pylatexenc.latex2text import LatexNodes2Text
import yaml

from resume.config import get_config, ResumeConfig
from resume.models import (
    ParsedResume, ResumeMetadata, PersonalInfo, BulletPoint,
    ExperienceEntry, EducationEntry, SkillsSection
)
from resume.macro_expander import LaTeXMacroExpander
from resume.section_extractor import SectionExtractor

logger = logging.getLogger(__name__)


class LaTeXResumeParser:
    """
    Robust LaTeX resume parser using regex + pylatexenc [web:76][web:77]
    
    - Uses regex for structural parsing (sections, itemize) [web:81]
    - Uses pylatexenc for macro expansion and text conversion [web:77]
    - Handles enumitem optional args properly [web:69]
    - No TexSoup dependency
    """
    
    # Personal info patterns
    PERSONAL_PATTERNS = {
        'name': [
            re.compile(r'\\name\s*\{([^}]+)\}', re.IGNORECASE),
            re.compile(r'\\author\s*\{([^}]+)\}', re.IGNORECASE),
        ],
        'email': [
            re.compile(r'\\email\s*\{([^}]+)\}', re.IGNORECASE),
            re.compile(r'([a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,})'),
        ],
        'phone': [
            re.compile(r'\\phone\s*\{([^}]+)\}', re.IGNORECASE),
            re.compile(r'\\mobile\s*\{([^}]+)\}', re.IGNORECASE),
        ],
        'location': [
            re.compile(r'\\location\s*\{([^}]+)\}', re.IGNORECASE),
            re.compile(r'\\address\s*\{([^}]+)\}', re.IGNORECASE),
        ],
        'linkedin': [
            re.compile(r'\\linkedin\s*\{([^}]+)\}', re.IGNORECASE),
            re.compile(r'linkedin\.com/in/([a-zA-Z0-9-]+)'),
        ],
        'github': [
            re.compile(r'\\github\s*\{([^}]+)\}', re.IGNORECASE),
            re.compile(r'github\.com/([a-zA-Z0-9-]+)'),
        ],
    }
    
    # Experience entry pattern (Title -- Company or Title | Company)
    EXPERIENCE_TITLE_PATTERN = re.compile(
        r'^(.+?)\s*(?:--|â€”|\||@)\s*(.+?)$',
        re.MULTILINE
    )
    
    # Date range patterns
    DATE_PATTERN = re.compile(
        r'(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)[a-z]*\.?\s+\d{4}',
        re.IGNORECASE
    )
    
    def __init__(self, config: Optional[ResumeConfig] = None):
        self.config = config or get_config()
        self.macro_expander = LaTeXMacroExpander()
        self.section_extractor = SectionExtractor()
        self.latex2text = LatexNodes2Text()
    
    def parse_file(self, filepath: str) -> ParsedResume:
        """
        Parse LaTeX resume file [web:76]
        
        Args:
            filepath: Path to .tex file
        
        Returns:
            ParsedResume object
        """
        filepath = Path(filepath)
        
        if not filepath.exists():
            raise FileNotFoundError(f"Resume file not found: {filepath}")
        
        logger.info(f"Parsing resume: {filepath}")
        
        with open(filepath, 'r', encoding='utf-8') as f:
            content = f.read()
        
        # Extract YAML frontmatter
        metadata = self._extract_frontmatter(content)
        content = self._remove_frontmatter(content)
        
        # Extract and store macro definitions [web:72]
        custom_macros = self.macro_expander.extract_macro_definitions(content)
        
        # Remove macro definitions from content (cleaner parsing)
        content_without_defs = self.macro_expander.remove_macro_definitions(content)
        
        # Extract sections [web:81]
        sections = self.section_extractor.extract_sections(content_without_defs)
        
        # Initialize parsed resume
        resume = ParsedResume(
            metadata=metadata,
            source_file=str(filepath),
            personal=PersonalInfo(),
            custom_commands=custom_macros
        )
        
        # Extract personal info
        resume.personal = self._extract_personal_info(content)
        
        # Extract section content
        resume.summary = self._extract_summary(sections, content_without_defs)
        resume.experience = self._extract_experience(sections)
        resume.education = self._extract_education(sections)
        resume.skills = self._extract_skills(sections)
        resume.certifications = self._extract_list_section(sections, 'certifications?')
        resume.awards = self._extract_list_section(sections, 'awards?|honors?')
        resume.projects = self._extract_projects(sections)
        
        # Collect all bullets
        resume.all_bullets = self._collect_all_bullets(resume)
        
        logger.info(f"Parsed resume: {len(resume.all_bullets)} bullets, "
                   f"{len(resume.experience)} experiences")
        
        return resume
    
    def _extract_frontmatter(self, content: str) -> ResumeMetadata:
        """Extract YAML frontmatter from document [web:59]"""
        if not content.startswith('---'):
            return ResumeMetadata()
        
        try:
            parts = content.split('---', 2)
            if len(parts) < 3:
                return ResumeMetadata()
            
            yaml_content = parts[1].strip()
            data = yaml.safe_load(yaml_content)
            
            if not data:
                return ResumeMetadata()
            
            return ResumeMetadata(
                name=data.get('name'),
                target_role=data.get('target_role'),
                version=data.get('version', '1.0.0'),
                tags=data.get('tags', []),
                custom_fields=data
            )
        
        except Exception as e:
            logger.warning(f"Failed to parse frontmatter: {e}")
            return ResumeMetadata()
    
    def _remove_frontmatter(self, content: str) -> str:
        """Remove YAML frontmatter"""
        if not content.startswith('---'):
            return content
        
        parts = content.split('---', 2)
        if len(parts) >= 3:
            return parts[2].strip()
        
        return content
    
    def _extract_personal_info(self, content: str) -> PersonalInfo:
        """Extract personal information using patterns"""
        personal = PersonalInfo()
        
        for field, patterns in self.PERSONAL_PATTERNS.items():
            for pattern in patterns:
                match = pattern.search(content)
                if match:
                    value = match.group(1).strip()
                    # Clean LaTeX formatting
                    value = self.latex2text.latex_to_text(value)
                    setattr(personal, field, value)
                    break  # Use first match
        
        return personal
    
    def _extract_summary(self, sections: List, content: str) -> Optional[str]:
        """Extract professional summary/objective"""
        section = self.section_extractor.find_section_by_name(
            sections,
            r'summary|objective|profile'
        )
        
        if section:
            # Get first paragraph (before any lists)
            text = section.content.split('\\begin{itemize}')[0]
            text = text.split('\\begin{enumerate}')[0]
            
            # Convert to plain text
            text = self.latex2text.latex_to_text(text).strip()
            
            if len(text) > 50:
                return text
        
        return None
    
    def _extract_experience(self, sections: List) -> List[ExperienceEntry]:
        """Extract work experience section"""
        experiences = []
        
        # Find experience section
        exp_section = self.section_extractor.find_section_by_name(
            sections,
            r'experience|work\s*history|employment'
        )
        
        if not exp_section:
            logger.warning("No experience section found")
            return experiences
        
        # Extract subsections (each job)
        subsections = self.section_extractor.extract_subsections(exp_section.content)
        
        for subsection_title, subsection_content in subsections:
            try:
                entry = self._parse_experience_entry(
                    subsection_title,
                    subsection_content
                )
                if entry:
                    experiences.append(entry)
            except Exception as e:
                logger.error(f"Failed to parse experience: {e}")
                continue
        
        logger.info(f"Extracted {len(experiences)} experience entries")
        return experiences
    
    def _parse_experience_entry(
        self,
        title_line: str,
        content: str
    ) -> Optional[ExperienceEntry]:
        """Parse individual experience entry"""
        # Parse title line (Title -- Company or Title | Company)
        title_match = self.EXPERIENCE_TITLE_PATTERN.search(title_line)
        
        if title_match:
            title = self.latex2text.latex_to_text(title_match.group(1).strip())
            company = self.latex2text.latex_to_text(title_match.group(2).strip())
        else:
            # Fallback: use whole line as title
            title = self.latex2text.latex_to_text(title_line.strip())
            company = "Unknown"
        
        # Extract dates if present
        dates = self.DATE_PATTERN.findall(content)
        start_date = dates[0] if len(dates) > 0 else None
        end_date = dates[1] if len(dates) > 1 else start_date
        
        # Extract location if present
        location_match = re.search(r'\\textit\{([^}]+)\}.*?\\hfill', content)
        location = location_match.group(1) if location_match else None
        
        # Extract bullets from itemize blocks
        bullets = []
        itemize_blocks = self.section_extractor.extract_itemize_blocks(content)
        
        for block in itemize_blocks:
            for i, item_text in enumerate(block['items']):
                # Expand macros in bullet text
                expanded_text = self.macro_expander.expand_text(item_text)
                
                # Convert to plain text
                plain_text = self.latex2text.latex_to_text(expanded_text).strip()
                
                # Check if this bullet uses a custom command
                cmd_name = self._find_macro_in_text(
                    item_text,
                    set(self.macro_expander.custom_macros.keys())
                )
                
                bullet = BulletPoint(
                    id=f"{company.replace(' ', '_').lower()}_{i}",
                    text=plain_text,
                    section='experience',
                    subsection=company,
                    is_modifiable=True,
                    command_name=cmd_name,
                    original_text=item_text if cmd_name else None
                )
                bullets.append(bullet)
        
        return ExperienceEntry(
            title=title,
            company=company,
            location=location,
            start_date=start_date,
            end_date=end_date,
            bullets=bullets
        )
    
    def _extract_education(self, sections: List) -> List[EducationEntry]:
        """Extract education section"""
        education = []
        
        edu_section = self.section_extractor.find_section_by_name(
            sections,
            r'education'
        )
        
        if not edu_section:
            return education
        
        # Extract subsections
        subsections = self.section_extractor.extract_subsections(edu_section.content)
        
        for subsection_title, subsection_content in subsections:
            # Parse "Degree -- Institution" format
            title_match = self.EXPERIENCE_TITLE_PATTERN.search(subsection_title)
            
            if title_match:
                degree = self.latex2text.latex_to_text(title_match.group(1).strip())
                institution = self.latex2text.latex_to_text(title_match.group(2).strip())
            else:
                degree = self.latex2text.latex_to_text(subsection_title.strip())
                institution = ""
            
            # Extract graduation date
            dates = self.DATE_PATTERN.findall(subsection_content)
            grad_date = dates[0] if dates else None
            
            entry = EducationEntry(
                degree=degree,
                institution=institution,
                graduation_date=grad_date
            )
            education.append(entry)
        
        return education
    
    def _extract_skills(self, sections: List) -> SkillsSection:
        """Extract skills section"""
        skills = SkillsSection()
        
        skills_section = self.section_extractor.find_section_by_name(
            sections,
            r'skills|technical\s*skills|technologies'
        )
        
        if not skills_section:
            return skills
        
        # Convert to plain text
        text = self.latex2text.latex_to_text(skills_section.content)
        
        # Parse skill categories
        categories = {
            'technical': r'(?:Technical|Programming|Languages):\s*([^\n]+)',
            'tools': r'(?:Tools|Technologies|Platforms):\s*([^\n]+)',
            'languages': r'(?:Languages|Natural\s*Languages):\s*([^\n]+)',
        }
        
        for field, pattern in categories.items():
            match = re.search(pattern, text, re.IGNORECASE)
            if match:
                items = [s.strip() for s in match.group(1).split(',')]
                setattr(skills, field, items)
        
        return skills
    
    def _extract_projects(self, sections: List) -> List[Dict]:
        """Extract projects section"""
        projects = []
        
        proj_section = self.section_extractor.find_section_by_name(
            sections,
            r'projects?'
        )
        
        if not proj_section:
            return projects
        
        # Extract subsections
        subsections = self.section_extractor.extract_subsections(proj_section.content)
        
        for subsection_title, subsection_content in subsections:
            project_name = self.latex2text.latex_to_text(subsection_title.strip())
            description = self.latex2text.latex_to_text(subsection_content.strip())
            
            projects.append({
                'name': project_name,
                'description': description
            })
        
        return projects
    
    def _extract_list_section(self, sections: List, section_pattern: str) -> List[str]:
        """Extract simple list section (certifications, awards)"""
        items = []
        
        section = self.section_extractor.find_section_by_name(
            sections,
            section_pattern
        )
        
        if not section:
            return items
        
        # Extract itemize blocks
        itemize_blocks = self.section_extractor.extract_itemize_blocks(section.content)
        
        for block in itemize_blocks:
            for item_text in block['items']:
                # Expand macros
                expanded = self.macro_expander.expand_text(item_text)
                
                # Convert to plain text
                plain_text = self.latex2text.latex_to_text(expanded).strip()
                
                if plain_text:
                    items.append(plain_text)
        
        return items
    
    def _collect_all_bullets(self, resume: ParsedResume) -> List[BulletPoint]:
        """Collect all bullet points from all sections"""
        bullets = []
        
        # Experience bullets
        for exp in resume.experience:
            bullets.extend(exp.bullets)
        
        # Project bullets (if structured)
        for project in resume.projects:
            if 'bullets' in project:
                bullets.extend(project['bullets'])
        
        return bullets
    
    def _find_macro_in_text(self, text: str, macro_names: set) -> Optional[str]:
        """Check if text contains a custom macro call"""
        for macro_name in macro_names:
            pattern = r'\\' + re.escape(macro_name) + r'(?:\{\})?'
            if re.search(pattern, text):
                return macro_name
        
        return None

