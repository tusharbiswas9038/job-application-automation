# resume/latex_parser.py
import re
import logging
from pathlib import Path
from typing import Optional, Dict, List, Tuple, Any
from TexSoup import TexSoup
from pylatexenc.latex2text import LatexNodes2Text
import yaml

from resume.config import get_config, ResumeConfig
from resume.models import (
    ParsedResume, ResumeMetadata, PersonalInfo, BulletPoint,
    ExperienceEntry, EducationEntry, SkillsSection
)

logger = logging.getLogger(__name__)


class LaTeXResumeParser:
    """
    Parse LaTeX resume files using TexSoup [web:49][web:50]
    Extracts structured data and identifies modifiable sections
    """
    
    def __init__(self, config: Optional[ResumeConfig] = None):
        self.config = config or get_config()
        self.latex2text = LatexNodes2Text()
        
        # Compile regex patterns
        self.custom_command_pattern = re.compile(
            self.config.custom_bullet_pattern,
            re.DOTALL
        )
        self.bullet_pattern = re.compile(self.config.bullet_command_pattern)
    
    def parse_file(self, filepath: str) -> ParsedResume:
        """
        Parse LaTeX resume file [web:50]
        
        Args:
            filepath: Path to .tex file
        
        Returns:
            ParsedResume object
        """
        filepath = Path(filepath)
        
        if not filepath.exists():
            raise FileNotFoundError(f"Resume file not found: {filepath}")
        
        logger.info(f"Parsing resume: {filepath}")
        
        with open(filepath, 'r', encoding='utf-8') as f:
            content = f.read()
        
        # Extract YAML frontmatter if present [web:59][web:66]
        metadata = self._extract_frontmatter(content)
        
        # Remove frontmatter from content
        content = self._remove_frontmatter(content)
        
        # Parse LaTeX with TexSoup [web:49]
        try:
            soup = TexSoup(content)
        except Exception as e:
            logger.error(f"Failed to parse LaTeX: {e}")
            raise ValueError(f"Invalid LaTeX syntax in {filepath}: {e}")
        
        # Extract custom commands
        custom_commands = self._extract_custom_commands(content)
        
        # Initialize parsed resume
        resume = ParsedResume(
            metadata=metadata,
            source_file=str(filepath),
            personal=PersonalInfo(),
            custom_commands=custom_commands
        )
        
        # Extract personal info
        resume.personal = self._extract_personal_info(soup)
        
        # Extract sections
        resume.summary = self._extract_summary(soup)
        resume.experience = self._extract_experience(soup, custom_commands)
        resume.education = self._extract_education(soup)
        resume.skills = self._extract_skills(soup)
        resume.certifications = self._extract_list_section(soup, 'certifications')
        resume.awards = self._extract_list_section(soup, 'awards')
        resume.projects = self._extract_projects(soup, custom_commands)
        
        # Collect all bullets
        resume.all_bullets = self._collect_all_bullets(resume)
        
        logger.info(f"Parsed resume: {len(resume.all_bullets)} bullets, "
                   f"{len(resume.experience)} experiences")
        
        return resume
    
    def _extract_frontmatter(self, content: str) -> ResumeMetadata:
        """
        Extract YAML frontmatter [web:59][web:63]
        
        Format:
        ---
        name: John Doe
        target_role: Kafka Administrator
        version: 1.0.0
        tags: [kafka, devops, platform]
        ---
        """
        if not content.startswith('---'):
            return ResumeMetadata()
        
        try:
            # Split on --- delimiters
            parts = content.split('---', 2)
            if len(parts) < 3:
                return ResumeMetadata()
            
            yaml_content = parts[1].strip()
            data = yaml.safe_load(yaml_content)
            
            if not data:
                return ResumeMetadata()
            
            return ResumeMetadata(
                name=data.get('name'),
                target_role=data.get('target_role'),
                version=data.get('version', '1.0.0'),
                tags=data.get('tags', []),
                custom_fields=data
            )
        
        except Exception as e:
            logger.warning(f"Failed to parse frontmatter: {e}")
            return ResumeMetadata()
    
    def _remove_frontmatter(self, content: str) -> str:
        """Remove YAML frontmatter from content"""
        if not content.startswith('---'):
            return content
        
        parts = content.split('---', 2)
        if len(parts) >= 3:
            return parts[2].strip()
        
        return content
    
    def _extract_custom_commands(self, content: str) -> Dict[str, str]:
        """
        Extract custom LaTeX commands [web:65]
        
        Example:
        \\newcommand{\\kafkaBulletOne}{Administered 50-node cluster...}
        """
        commands = {}
        
        for match in self.custom_command_pattern.finditer(content):
            cmd_name = match.group(1)
            cmd_text = match.group(2)
            
            # Convert LaTeX to plain text [web:54]
            plain_text = self.latex2text.latex_to_text(cmd_text)
            
            commands[cmd_name] = plain_text.strip()
        
        logger.debug(f"Found {len(commands)} custom commands")
        return commands
    
    def _extract_personal_info(self, soup: TexSoup) -> PersonalInfo:
        """
        Extract personal information from resume [web:64]
        
        Common patterns:
        - \\name{John Doe}
        - \\email{john@example.com}
        - \\phone{555-1234}
        - \\linkedin{linkedin.com/in/johndoe}
        """
        personal = PersonalInfo()
        
        # Try to find name
        name_candidates = ['name', 'firstname', 'author']
        for cmd in name_candidates:
            name_elem = soup.find(cmd)
            if name_elem:
                personal.name = self._extract_text(name_elem)
                break
        
        # Extract contact info
        contact_fields = {
            'email': 'email',
            'phone': 'phone',
            'mobile': 'phone',
            'address': 'location',
            'location': 'location',
            'linkedin': 'linkedin',
            'github': 'github',
            'homepage': 'website',
            'website': 'website'
        }
        
        for latex_cmd, field_name in contact_fields.items():
            elem = soup.find(latex_cmd)
            if elem:
                value = self._extract_text(elem)
                if value:
                    setattr(personal, field_name, value)
        
        return personal
    
    def _extract_summary(self, soup: TexSoup) -> Optional[str]:
        """Extract professional summary/objective"""
        summary_sections = ['summary', 'objective', 'profile']
        
        for section_name in summary_sections:
            section = soup.find('section', string=re.compile(section_name, re.I))
            if section:
                # Get content after section heading
                text = self._extract_section_text(section)
                if text and len(text) > 50:
                    return text
        
        return None
    
    def _extract_experience(
        self, 
        soup: TexSoup, 
        custom_commands: Dict[str, str]
    ) -> List[ExperienceEntry]:
        """
        Extract work experience section [web:64][web:67]
        
        Common structure:
        \\section{Experience}
        \\subsection{Title -- Company}
        \\textit{Location} \\hfill \\textit{Date Range}
        \\begin{itemize}
            \\item Bullet one
            \\item Bullet two
        \\end{itemize}
        """
        experiences = []
        
        # Find Experience section
        exp_section = soup.find('section', string=re.compile(r'experience|work history', re.I))
        if not exp_section:
            logger.warning("No experience section found")
            return experiences
        
        # Find all subsections (each job)
        parent = exp_section.parent
        subsections = list(parent.find_all('subsection'))
        
        for subsection in subsections:
            try:
                entry = self._parse_experience_entry(subsection, custom_commands)
                if entry:
                    experiences.append(entry)
            except Exception as e:
                logger.error(f"Failed to parse experience entry: {e}")
                continue
        
        logger.info(f"Extracted {len(experiences)} experience entries")
        return experiences
    
    def _parse_experience_entry(
        self,
        subsection,
        custom_commands: Dict[str, str]
    ) -> Optional[ExperienceEntry]:
        """Parse individual experience entry"""
        # Extract title from subsection
        title_text = self._extract_text(subsection)
        
        # Parse "Title -- Company" or "Title | Company" format
        if '--' in title_text:
            parts = title_text.split('--', 1)
        elif '|' in title_text:
            parts = title_text.split('|', 1)
        else:
            parts = [title_text, '']
        
        title = parts[0].strip()
        company = parts[1].strip() if len(parts) > 1 else ''
        
        # Extract bullets from itemize environment
        bullets = []
        parent = subsection.parent
        
        # Find next itemize after this subsection
        itemize = None
        for child in parent.children:
            if child == subsection:
                continue
            if hasattr(child, 'name') and child.name == 'itemize':
                itemize = child
                break
        
        if itemize:
            items = list(itemize.find_all('item'))
            for i, item in enumerate(items):
                bullet_text = self._extract_text(item)
                
                # Check if bullet uses custom command
                cmd_name = self._find_command_name(bullet_text, custom_commands)
                if cmd_name:
                    bullet_text = custom_commands[cmd_name]
                
                bullet = BulletPoint(
                    id=f"{company.replace(' ', '_')}_{i}",
                    text=bullet_text,
                    section='experience',
                    subsection=company,
                    is_modifiable=True,
                    command_name=cmd_name
                )
                bullets.append(bullet)
        
        return ExperienceEntry(
            title=title,
            company=company,
            bullets=bullets
        )
    
    def _extract_education(self, soup: TexSoup) -> List[EducationEntry]:
        """Extract education section"""
        education = []
        
        edu_section = soup.find('section', string=re.compile(r'education', re.I))
        if not edu_section:
            return education
        
        parent = edu_section.parent
        subsections = list(parent.find_all('subsection'))
        
        for subsection in subsections:
            text = self._extract_text(subsection)
            
            # Parse "Degree -- Institution" format
            if '--' in text:
                degree, institution = text.split('--', 1)
            else:
                degree = text
                institution = ''
            
            entry = EducationEntry(
                degree=degree.strip(),
                institution=institution.strip()
            )
            education.append(entry)
        
        return education
    
    def _extract_skills(self, soup: TexSoup) -> SkillsSection:
        """
        Extract skills section
        
        Format:
        \\section{Skills}
        \\textbf{Technical:} Kafka, Zookeeper, Python
        \\textbf{Tools:} Docker, Kubernetes
        """
        skills = SkillsSection()
        
        skills_section = soup.find('section', string=re.compile(r'skills|technologies', re.I))
        if not skills_section:
            return skills
        
        # Get all text after section
        parent = skills_section.parent
        text = self._extract_section_text(parent)
        
        # Parse skill categories
        categories = {
            'technical': r'(?:Technical|Programming|Languages):\s*([^\n]+)',
            'tools': r'(?:Tools|Technologies|Platforms):\s*([^\n]+)',
            'languages': r'(?:Languages|Natural Languages):\s*([^\n]+)',
        }
        
        for field, pattern in categories.items():
            match = re.search(pattern, text, re.IGNORECASE)
            if match:
                items = [s.strip() for s in match.group(1).split(',')]
                setattr(skills, field, items)
        
        return skills
    
    def _extract_projects(
        self,
        soup: TexSoup,
        custom_commands: Dict[str, str]
    ) -> List[Dict[str, Any]]:
        """Extract projects section"""
        projects = []
        
        proj_section = soup.find('section', string=re.compile(r'projects', re.I))
        if not proj_section:
            return projects
        
        parent = proj_section.parent
        subsections = list(parent.find_all('subsection'))
        
        for subsection in subsections:
            project_name = self._extract_text(subsection)
            
            # Find description/bullets
            description = self._extract_section_text(subsection.parent)
            
            projects.append({
                'name': project_name,
                'description': description
            })
        
        return projects
    
    def _extract_list_section(self, soup: TexSoup, section_name: str) -> List[str]:
        """Extract simple list section (certifications, awards)"""
        items = []
        
        section = soup.find('section', string=re.compile(section_name, re.I))
        if not section:
            return items
        
        parent = section.parent
        itemize = parent.find('itemize')
        
        if itemize:
            for item in itemize.find_all('item'):
                text = self._extract_text(item)
                if text:
                    items.append(text)
        
        return items
    
    def _collect_all_bullets(self, resume: ParsedResume) -> List[BulletPoint]:
        """Collect all bullet points from all sections"""
        bullets = []
        
        # Experience bullets
        for exp in resume.experience:
            bullets.extend(exp.bullets)
        
        # Project bullets (if structured)
        for project in resume.projects:
            if 'bullets' in project:
                bullets.extend(project['bullets'])
        
        return bullets
    
    def _extract_text(self, element) -> str:
        """Extract plain text from TexSoup element [web:51]"""
        if element is None:
            return ""
        
        # Get string representation
        latex_str = str(element)
        
        # Convert LaTeX to plain text [web:54][web:57]
        plain_text = self.latex2text.latex_to_text(latex_str)
        
        return plain_text.strip()
    
    def _extract_section_text(self, section) -> str:
        """Extract all text content from section"""
        if section is None:
            return ""
        
        # Get all descendants
        text_parts = []
        for child in section.descendants:
            if isinstance(child, str):
                text_parts.append(child)
        
        full_text = ' '.join(text_parts)
        return self.latex2text.latex_to_text(full_text).strip()
    
    def _find_command_name(self, text: str, custom_commands: Dict[str, str]) -> Optional[str]:
        """Check if text matches a custom command"""
        for cmd_name, cmd_text in custom_commands.items():
            if cmd_text == text:
                return cmd_name
        return None

